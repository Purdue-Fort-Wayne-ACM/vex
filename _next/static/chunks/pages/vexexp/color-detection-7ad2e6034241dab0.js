(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[900],{4384:(e,n,t)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/vexexp/color-detection",function(){return t(9369)}])},9369:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>d});var o=t(7876),r=t(3923),s=t(8144);t(8227);var i=t(6004),a=t(7745);t(6522);var l=t(1621);let c=function(e){let{children:n}=e;return(0,o.jsx)(s.S,{children:n})};function h(e){let n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(i.A,{children:[(0,o.jsx)(n.h1,{children:"Color Detection"}),(0,o.jsx)(n.p,{children:"This page addresses some common issues one might encounter when attempting to detect colors using Python and Vex on the Vex EXP. You are not required to implement any of these strategies,\nbut they should instead serve as guides and examples for what you might want to do."}),(0,o.jsx)(n.h2,{children:"A Common Color Detection Method"}),(0,o.jsx)(n.p,{children:"A common method for color detection one may use is similar to the following:"}),(0,o.jsx)(l.zI,{code:"from vex import *\noptical_sensor = Optical(Ports.PORT1) # Substitute with your port number\n\nif optical_sensor.color() == Color.BLUE:\n  do_thing_one() # An imaginary function\nelse:\n  do_thing_two() # An imaginary function\n\n      ",tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsxs)(n.p,{children:["This code is fine. If it detects a perfect Blue, it will do the first function, and in all other cases it will do the second function. But is this actually what you want?\nLet's say that our blue line is less of a handicap blue, and more of a purpley-blue, or a lighter blue. What if it's an aquamarine color? Will this return a ",(0,o.jsx)(n.code,{children:"True"})," value?"]}),(0,o.jsx)(n.p,{children:"The answer is no!"}),(0,o.jsxs)(n.p,{children:["Let's take a look at how that color is actually implemented according to their website: ",(0,o.jsx)(n.a,{href:"https://api.vex.com/exp/home/python/Enums.html#color-types",children:"Vex Color Types"})]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"| Name        | Python Enum | Description                                                                |\n|-------------|-------------|----------------------------------------------------------------------------|\n| Red         | RED         | The predefined color constant for red as the RGB value: (255, 0, 0).       |\n| Green       | GREEN       | The predefined color constant for green as the RGB value: (0, 255, 0).     |\n| Blue        | BLUE        | The predefined color constant for blue as the RGB value: (0, 0, 255).      |\n| Yellow      | YELLOW      | The predefined color constant for yellow as the RGB value: (255, 255, 0).  |\n| Orange      | ORANGE      | The predefined color constant for orange as the RGB value: (255, 165, 0).  |\n| Purple      | PURPLE      | The predefined color constant for purple as the RGB value: (255, 0, 255).  |\n| Cyan        | CYAN        | The predefined color constant for cyan as the RGB value: (0, 255, 255).    |\n| Black       | BLACK       | The predefined color constant for black as the RGB value: (0, 0, 0).       |\n| White       | WHITE       | The predefined color constant for white as the RGB value: (255, 255, 255). |\n| Transparent | TRANSPARENT | The predefined color constant for transparent.                             |\n"})}),(0,o.jsx)(n.p,{children:"If we want to read this, it's important to address how colors work in computers (and on the Vex robots)."}),(0,o.jsx)(n.h3,{children:"Color Theory?"}),(0,o.jsx)(n.p,{children:"Colors that come from light are considered additive. The less light we add the darker it is (and closer to black), the more light we add the brighter it is (and closer to white).\nWe have three primary colors we can detect - Red, Green, and Blue. By adding different amounts of these three colors to a light, we can change what color it's perceived as.\nWe call these different commponents channels, and it's where the term RGB comes from. We typically measure the value of these channels from 0 to 255 (a byte of precision)\nBut sometimes different values are used, like a decimal value between 0 and 1. The colors that Vex provides us are at the different endpoints of the RGB color space - They either have 100% or 0% of each channel.\nFor example, Colors.BLUE is (0, 0, 255) - 0% red, 0% green, and 100% blue."}),(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"/images/rgb-space.png",alt:"The Vex colors in RGB space",title:"The cardinal colors, primary and secondary"})}),(0,o.jsxs)(n.p,{children:["According to their documentation, Blue is a specific shade of blue - a perfect blue. A quick search of the internet might lead us to a catalog of different blues\nsuch as ",(0,o.jsx)(n.a,{href:"https://html-color.codes/blue",children:"this one"})," which shows us that other blues ",(0,o.jsx)(n.em,{children:"don't"})," have that same makeup. This means if we compare them, they won't be equal."]})]}),"\n",(0,o.jsx)(a.A,{questions:[{question:"What color would the rgb value (0, 255, 0) represent?",options:["Blue","Purple","Green","Red"],correctAnswer:2,explanation:"The RGB values are measured from 0 to 255. The given RGB value represents 0% Red, 100% Green, and 0% Blue."}]}),"\n",(0,o.jsxs)(i.A,{children:[(0,o.jsx)(n.p,{children:"We run into a similar issue for saving and storing colors! If we make a color that perfectly matches the sensor reading in one environment, the value read in a\ndifferent environment might be slightly off. Consider how turning the optical sensor's light on and off affects the hue and intensity read. Both of these issues stem\nfrom the same problem: We're attempting to exactly match a color."}),(0,o.jsx)(n.p,{children:"So how can we solve this? We have a few good options:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Compare components"}),"\n",(0,o.jsx)(n.li,{children:"Compare intensities"}),"\n",(0,o.jsx)(n.li,{children:"Compare the amount of color total"}),"\n",(0,o.jsx)(n.li,{children:"Cluster colors by distance"}),"\n"]}),(0,o.jsx)(n.h2,{children:"Comparing RGB Components"}),(0,o.jsxs)(n.p,{children:["As we said earlier, an RGB color is made up of multiple 'channels' representing the amount of each primary color. We can also refer to these channels as the 'components'\nof the color. By separating a color into its various components, we can make decisions based off of them. Vex doesn't directly expose the color components to us (to my knowledge). Instead, we get a hex-string representing the color channels.\nThe strings are in the form ",(0,o.jsx)(n.code,{children:"Color 00XXXXXX"}),", where the Xs represent hex values. Black would be ",(0,o.jsx)(n.code,{children:"Color 00000000"}),", Blue would be ",(0,o.jsx)(n.code,{children:"Color 000000FF"}),", and so on."]}),(0,o.jsx)(n.p,{children:"We want to extract our components from this string! We can do that with something like the following program:"}),(0,o.jsx)(l.zI,{code:"from vex import *\n\ndef color_to_rgb(input: Color):\n  hex_str = str(input)[8:] # ignore first 2 hex values\n  return (\n      int(hex_str[0:2], 16),\n      int(hex_str[2:4], 16),\n      int(hex_str[4:6], 16)\n  )\n\n# Begin project code\n\nprint(color_to_rgb(Color(107, 34, 56))) # creates a color from RGB, and then immediately converts it back. ",tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsxs)(n.p,{children:["Essentially this will cut off the first part of the string, ",(0,o.jsx)(n.code,{children:"Color 00"}),", then it will split up the remaining hex codes. It will then make a tuple out of the three channels. This lets us access the components!"]}),(0,o.jsx)(n.p,{children:"Once we do this, we can check the different channels for specific properties. For instance, we could find out which of the three channels is largest and use that to determine how we behave:"}),(0,o.jsx)(l.zI,{code:'from vex import *\n\ndef color_to_rgb(input: Color):\n  hex_str = str(input)[8:] # ignore first 2 hex values\n  return (\n      int(hex_str[0:2], 16),\n      int(hex_str[2:4], 16),\n      int(hex_str[4:6], 16)\n  )\n\n# Begin project code\nbrain = Brain() # Instantiate brain\noptical = Optical(Ports.PORT1) # Port2 is the optical sensor\noptical.set_light(LedStateType.ON)\n\n\nwhile True:\n      scanned_color = optical.color()\n      color_components = color_to_rgb(scanned_color)\n      \n      channel_index = color_components.index(max(color_components)) # This finds the maximum channel of the scanned color\n      \n      if channel_index == 0:\n          brain.screen.print("RED")\n      if channel_index == 1:\n          brain.screen.print("GREEN")\n      if channel_index == 2:\n          brain.screen.print("BLUE")\n      \n      brain.screen.set_cursor(1,1) # reset the cursor\n      wait(0.5, SECONDS)\n      brain.screen.clear_screen()\n',tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsx)(n.p,{children:"This gives a good framework for making decisions with respect to the primary colors!"}),(0,o.jsx)(n.h2,{children:"Comparing Other Color Components"}),(0,o.jsx)(n.p,{children:"While we can use the RGB channels as components of a color, we have an alternative system - Hue, Saturation, and Value or Hue, Saturation, and Luminence (abbreviated HSV and HSL respectively)."}),(0,o.jsxs)(n.p,{children:["Hue represents the actual color around the color wheel. It is measured in a value from 0-360, and it's ",(0,o.jsx)(n.a,{href:"https://api.vex.com/exp/home/python/Optical.html#hue",children:"one of the fields"})," the optical sensor can provide us."]}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.img,{src:"/images/hue-scale.png",alt:"Hue Bar",title:"Hue Bar"}),"\n",(0,o.jsx)(n.img,{src:"/images/color-wheel.png",alt:"Hue Circle",title:"Hue Color Wheel"})]}),(0,o.jsx)(n.p,{children:"Vex makes it somewhat easy for us to get this value out:"}),(0,o.jsx)(l.zI,{code:"from vex import *\n\n# Begin project code\nbrain = Brain() # Instantiate brain\noptical = Optical(Ports.PORT1) # Port2 is the optical sensor\noptical.set_light(LedStateType.ON)\n\n\nwhile True:\n      hue = optical.hue()\n      print(hue)",tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsx)(n.p,{children:"Saturation represents the depth or strength of that color. It is basically the 'amount' of that color represented. You need the luminence value alongside the RGB value to accurately calculate the saturation. But generally, it's represented as the portion of color used.\nWe take each RGB channel, and find the max and min values among them. Then we calculate saturation as `(max-min)/max)."}),(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"/images/saturation-calculation.png",alt:"Saturation",title:"Saturation Calculation"})}),(0,o.jsx)(l.zI,{code:"from vex import *\n\ndef color_to_rgb(input: Color):\n  hex_str = str(input)[8:] # ignore first 2 hex values\n  return (\n      int(hex_str[0:2], 16),\n      int(hex_str[2:4], 16),\n      int(hex_str[4:6], 16)\n  )\n\n# Begin project code\nbrain = Brain() # Instantiate brain\noptical = Optical(Ports.PORT1) # Port2 is the optical sensor\noptical.set_light(LedStateType.ON)\n\n\nwhile True:\n      rgb_channels = color_to_rgb(optical.color()) # get current color RGB channels\n      max_val = max(rgb_channels)\n      min_val = min(rgb_channels)\n      saturation = (max_val-min_val)/max_val\n\n      brain.screen.print(saturation)\n\n      brain.screen.set_cursor(1,1) # reset the cursor\n      wait(0.5, SECONDS)\n      brain.screen.clear_screen()\n",tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsx)(n.p,{children:"Value/Luminance represents the brightness, with 0% being black, and 100% being a bright version of the specified color."}),(0,o.jsx)(n.p,{children:"Vex makes it somewhat easy for us to get this value out:"}),(0,o.jsx)(l.zI,{code:"from vex import *\n\n# Begin project code\nbrain = Brain() # Instantiate brain\noptical = Optical(Ports.PORT1) # Port2 is the optical sensor\noptical.set_light(LedStateType.ON)\n\n\nwhile True:\n      hue = optical.brightness()\n      print(hue)",tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"/images/hsv-cone.png",alt:"Hue Cone",title:"Hue Color Wheel"})}),(0,o.jsx)(n.p,{children:"Once we have calculated any of these components, we can use them to make decisions. For example, if we wanted our program to do something on any green color, we could have it operate on any hues from 60degrees to 180degrees!"}),(0,o.jsx)(l.zI,{code:"from vex import *\n\n# Begin project code\nbrain = Brain() # Instantiate brain\noptical = Optical(Ports.PORT1) # Port2 is the optical sensor\noptical.set_light(LedStateType.ON)\n\n\nwhile True:\n      hue = optical.hue()\n      if hue > 60 and hue < 180: # We're green!\n              do_something()\n      else:\n              do_opposite_something()",tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsx)(n.h2,{children:"Comparing Total Color"}),(0,o.jsx)(n.p,{children:"We may want to perform our decisions based on the amount of color across all channels. To do this, we can add the channel components."}),(0,o.jsx)(l.zI,{code:'from vex import *\n\ndef color_to_rgb(input: Color):\n  hex_str = str(input)[8:] # ignore first 2 hex values\n  return (\n      int(hex_str[0:2], 16),\n      int(hex_str[2:4], 16),\n      int(hex_str[4:6], 16)\n  )\n\n# Begin project code\noptical = Optical(Ports.PORT1)\n\nTHRESH = 400\n\nwhile True:\n      rgb_channels = color_to_rgb(optical.color())\n      value = sum(rgb_channels)\n\n      if value > THRESH:\n              print("We exceeded our threshold!")\n      else:\n              print("We are too small")\n',tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsx)(n.h2,{children:"Clustering Colors"}),(0,o.jsx)(n.p,{children:"This method is likely the most robust, but may also be more difficult to implement and understand."}),(0,o.jsx)(n.p,{children:"When we discuss clustering colors, what we mean is grouping them, by their distance from something. That might be their distance from another color, or their distance\nfrom a specific point in space (such as the center of a mass). We essentially choose some target points for our groups, or 'clusters', and we choose a boundary distance.\nAnything below that distance belongs to the corresponding cluster. Anything above that distance belongs outside of it. Let's look at a 2D example."}),(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"/images/2d-clustering.png",alt:"A 2D clustering example",title:"2D point clustering"})}),(0,o.jsx)(n.p,{children:"I have marked our clustering point (often called a 'centroid') in orange, and the boundary distance in green. We will call this the cool cluster. All of the green points\nbelong to the cool cluster, and all of the purple points don't. We could consider the purple points to be their own cluster, or we could consider them to be unclustered."}),(0,o.jsx)(n.p,{children:"Another way we might cluster is to put a point into whichever group it is closest to. To do that, we can just take our group os cluster points, and\ncompute a target point's distance for all of them, then find the smallest."}),(0,o.jsx)(n.p,{children:"The circle in our example exists to represent the distance from the orange point, but in our code we won't have a circle - we'll just have coordinates. Luckily there's an equation.\nknown as the euclidean distance formula."}),(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"/images/2d-euclid-distance.png",alt:"A 2D clustering formula",title:"Euclidean Distance Formula"})}),(0,o.jsxs)(n.p,{children:["Where ",(0,o.jsx)(n.code,{children:"d"})," represents our distance!"]}),(0,o.jsxs)(n.p,{children:["There is also a 3D formula, where we can plug in our two points:\n",(0,o.jsx)(n.img,{src:"/images/3d-euclid-distance.png",alt:"A 3D clustering formula",title:"Euclidean Distance Formula"})]}),(0,o.jsx)(l.zI,{code:'from vex import *\nimport math\n\ndef color_to_rgb(input: Color):\n  hex_str = str(input)[8:] # ignore first 2 hex values\n  return (\n      int(hex_str[0:2], 16),\n      int(hex_str[2:4], 16),\n      int(hex_str[4:6], 16)\n  )\n\ndef euclidean_distance(p1, p2):\n  return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)\n\n# Begin project code\noptical = Optical(Ports.PORT1)\n\nBLACK_CHANNELS = color_to_rgb(Color.BLACK)\n\nwhile True:\n      rgb_channels = color_to_rgb(optical.color())\n      \n      value = euclidean_distance(BLACK_CHANNELS, rgb_channels) # Calculate the ditance\n\n      print("We have a distance of: " + value)\n',tooltips:l.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,o.jsx)(n.p,{children:"We may further apply a threshold to this calculated value."}),(0,o.jsxs)(n.p,{children:["Here's a ",(0,o.jsx)(n.a,{href:"https://interactables.pfw-acm.org/rgb-distances",children:"visualization"})," of that formula working with different colors."]}),(0,o.jsxs)(n.p,{children:["Here's a ",(0,o.jsx)(n.a,{href:"https://interactables.pfw-acm.org/rgb-partitions",children:"visualization"})," of that formula being used to cluster regions"]})]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,o.jsx)(c,{...e,children:(0,o.jsx)(h,{...e})})}}},e=>{var n=n=>e(e.s=n);e.O(0,[822,636,593,792],()=>n(4384)),_N_E=e.O()}]);