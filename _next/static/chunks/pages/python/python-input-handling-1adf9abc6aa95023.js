(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[934],{468:(e,t,n)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/python/python-input-handling",function(){return n(4511)}])},4511:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>l});var s=n(7876),i=n(3923),r=n(8144),o=n(6004),a=n(1621);n(9254);let h=function(e){let{children:t}=e;return(0,s.jsx)(r.S,{children:t})};function c(e){let t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(o.A,{children:[(0,s.jsx)(t.h1,{children:"What is Input?"}),(0,s.jsx)(t.p,{children:"Input is the feature of a program to accept data. We often see input in the form of username and password fields, payment details, file\nuploads, and comment boxes. In our case, input is used to control and orient our drones."}),(0,s.jsxs)(t.h3,{children:["Input with ",(0,s.jsx)(t.code,{children:"input"})]}),(0,s.jsxs)(t.p,{children:["Python has a built-in function for input, the ",(0,s.jsx)(t.code,{children:"input"})," function. The input function accepts a string, which it prints to the terminal, and\nthen waits until a user presses enter. If a user clicks enter/carriage return, then any characters they typed into the terminal get submitted\nas text input, which the function returns as a string. Try the following program out:"]}),(0,s.jsx)(a.zI,{code:'user_text = input("Try typing something: ") # The input function returns the user\'s text\n\nprint(user_text)',tooltips:a.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,s.jsx)(t.p,{children:"It will print out any text the user typed out. Once the user has submitted their input, it is a string we can do whatever we want to."}),(0,s.jsx)(t.h3,{children:"Input with Keyboard"}),(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"keyboard"})," module handles input differently. It registers with the operating system, and watches for 'events' - specific actions it should\nrespond to. This basically means we can listen for individual keys."]}),(0,s.jsxs)(t.p,{children:["We must install the ",(0,s.jsx)(t.code,{children:"keyboard"})," module, which is simple enough! Using the CMD, we can run ",(0,s.jsx)(t.code,{children:"pip install keyboard"}),". That should download the\nmodule we need."]}),(0,s.jsx)(t.p,{children:"Once we've downloaded it, we need to remember to import the module:"}),(0,s.jsx)(a.zI,{code:"import keyboard",tooltips:a.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,s.jsx)(t.p,{children:"Now, we're setup to use it! The keyboard module allows a few cool things:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Waiting - Keyboard can wait for a specific key to be pressed, and will stop the program until this happens (called blocking)"}),"\n",(0,s.jsxs)(t.li,{children:["Adding Hotkeys - Hotkeys are keys that cause a certain behavior or event. For instance ",(0,s.jsx)(t.code,{children:"ALT+TAB"}),", ",(0,s.jsx)(t.code,{children:"CTRL+ESC"}),", or ",(0,s.jsx)(t.code,{children:"CTRL+C/CTRL+V"})," are all\nsome example hotkeys!"]}),"\n",(0,s.jsx)(t.li,{children:"Hooking Keys - This is like adding hotkeys, but for specific individual keys."}),"\n"]}),(0,s.jsx)("br",{}),(0,s.jsx)(t.h4,{children:"Waiting for Keys"}),(0,s.jsx)(t.p,{children:"This allows us to wait for either a specific key, or any key."}),(0,s.jsx)("br",{}),(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Specific Key"}),(0,s.jsx)("br",{}),"\nTo wait for a specific key we can use ",(0,s.jsx)(t.code,{children:"keyboard.wait"}),", as below:"]}),(0,s.jsx)(a.zI,{code:"import keyboard\n\nkeyboard.wait('esc')\nprint(\"User clicked escape\")\n\nkeyboard.wait('esc+a')\nprint(\"User clicked escape plus A\")",tooltips:a.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,s.jsxs)(t.p,{children:["Notice that it doesn't just accept a single key, but a ",(0,s.jsx)(t.code,{children:"parseablehotkey"}),". This means you can specify multiple characters."]}),(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Awaiting any key"}),(0,s.jsx)("br",{}),"\nWe can also wait for a key to be pressed in general, and then use it. We do this using ",(0,s.jsx)(t.code,{children:"keyboard.read_key"}),". This function will return a ",(0,s.jsx)(t.code,{children:"Key_"}),"\ntype, so if we're checking for specific keys we want to convert it to a string first."]}),(0,s.jsx)(a.zI,{code:'while True:\n  key_pressed = str(keyboard.read_key()) # The str method converts to a string\n\n  if key == "a":\n      print("Lowercase a")\n  elif key == "A":\n      print("Uppercase A")\n  else:\n      print("Something else...")',tooltips:a.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,s.jsx)(t.p,{children:"If we want to listen without paying attention to capitalization, we can lowercase the string:"}),(0,s.jsx)(a.zI,{code:'while True:\n  key_pressed = str(keyboard.read_key()).lower() # The str method converts to a string\n\n  if key == "a":\n      print("Lowercase OR Uppercase a")\n  else:\n      print("Something else...")',tooltips:a.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,s.jsx)(t.h4,{children:"Adding Hotkeys"}),(0,s.jsx)(a.zI,{code:"import keyboard\n\nkeyboard.add_hotkey('ctrl+shift+a', print, args=('triggered', 'hotkey'))",tooltips:a.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,s.jsx)(t.p,{children:"The method expects the following parameters..."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"hotkey: _ParseableHotkey,\ncallback: (...) -> (bool | None),\nargs: _Ts = (),\nsuppress: bool = False,\ntimeout: float = 1,\ntrigger_on_release: bool = False\n"})}),(0,s.jsx)("br",{}),(0,s.jsx)(t.p,{children:"either provided in that order, or with the specific varnames specified. I will explain each parameter below:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Hotkey - This is what the user should actually click (together) specified as a string. Ie, 'ctrl+h'"}),"\n",(0,s.jsx)(t.li,{children:"Callback - A callback is a function that should be 'called' (or run) when some behavior happens. In our example above, that's the print\nmethod."}),"\n",(0,s.jsxs)(t.li,{children:["Args - This is a tuple (value specified in parenthesis, it cannot be modified) that gets passed to the function specified in ",(0,s.jsx)(t.code,{children:"callback"}),".\nIn our example it is ('triggered', 'hotkey'). When combined with the callback ",(0,s.jsx)(t.code,{children:"print"}),", it becomes ",(0,s.jsx)(t.code,{children:"print('triggered', 'hotkey')"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"Suppress - Optional, defaults to False. This is whether to 'suppress' the keys, meaning that they won't go through to the target program.\nOnly use this if you want to prevent keys from messing with the user's app."}),"\n",(0,s.jsx)(t.li,{children:"Timeout - Optional, defaults to 1. This is how long the user has in seconds to click all keys together."}),"\n",(0,s.jsx)(t.li,{children:"Trigger on release - Optional, defaults to false. This determines whether a hotkey triggers when the user first presses it down, or only\nwhen they release all keys."}),"\n"]}),(0,s.jsx)("br",{}),(0,s.jsx)(t.h4,{children:"Hooking Keys"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.h1,{children:"Blocking vs Non-Blocking User Input"}),(0,s.jsx)(t.p,{children:"Blocking input is input that stops the program, or which does something that the program can't move forward without. Non-Blocking input is a\nform of input that checks if input has been completed, and if not continues the program as usual. There are pros and cons to both approaches.\nFor instance, blocking input can be a bottleneck to a program stopping calculations or preventing simulation. Non-blocking input could result\nin a program doing something the user didn't want, or it checking too slowly, which could make input feel unresponsive. We should learn both\nstyles of collecting input in order to choose what benefits us most!"}),(0,s.jsx)(t.h2,{children:"Handling Blocking Input"}),(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"input"})," function is a blocking function - when we use it we pause the program. Consider the below example:"]}),(0,s.jsx)(a.zI,{code:'user_stuff = input("Say Something: ")\n\nprint("Notice that this doesn\'t print until AFTER you input your text.")',tooltips:a.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,s.jsx)(t.p,{children:"As previously mentioned, blocking input function will block the rest of your program from running until it finishes running (collecting input).\nIn many cases this is perfectly fine, or even preferred, such as collecting user data, or letting a user navigate through a menu or play\ncertain games. For other applications, such as us controlling our drones, this can be problematic."}),(0,s.jsx)(t.p,{children:"One way that we can address this is by using threads. Threads allow us to have a separate context for execution, which means that different\ncode is running at the same time. So we can have a thread which runs code, and then have a program which collects input, or in reverse we\ncould have a thread which runs important code, and a thread which uses input to update what the main code does. Consider the following example:"}),(0,s.jsx)(a.zI,{code:'import threading\n\ndef thread_function(thread_lock):\n  while thread_lock.is_set():\n      print("How do we do this? ")\n\nif __name__ == "__main__":\n  program_active = threading.Event()\n  program_active.set() # set a thread lock\n\n  thread = threading.Thread(target=thread_function, args=(program_active,))\n  thread.start()\n  \n  while True:\n      user_input = input("Type Text: ")\n      if user_input == "end":\n          program_active.clear()\n          thread.join()',tooltips:a.M2,theme:"dark",showLineNumbers:!0,copyButton:!0,className:"mb-6"}),(0,s.jsx)(t.h2,{children:"Handling Non-Blocking Input"}),(0,s.jsx)(t.h3,{children:"Using Threads"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.h3,{children:"Using Keyboard"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.h1,{children:"Parsing, Processing, and Input"}),(0,s.jsx)(t.h1,{children:"Files as User Input"}),(0,s.jsx)(t.h3,{children:"Parsing Files"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.h3,{children:"OpenCV File Access"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,s.jsx)(h,{...e,children:(0,s.jsx)(c,{...e})})}},9254:(e,t,n)=>{"use strict";n.d(t,{A:()=>i});var s=n(7876);function i(e){let{title:t="Terminal",children:n,className:i=""}=e;return(0,s.jsxs)("div",{className:"rounded-md border border-[#2e2e2e] bg-[#1e1e1e] text-[#d4d4d4] font-mono mb-3 ".concat(i),children:[(0,s.jsx)("div",{className:"flex justify-between items-center px-4 py-2.5 border-b border-[#2e2e2e] bg-[#2b2b2b]",children:(0,s.jsx)("span",{className:"text-sm text-[#dcdcdc]",children:t})}),(0,s.jsx)("pre",{className:"px-4 py-3 pb-1 pl-10 overflow-x-auto text-sm leading-relaxed whitespace-pre-wrap m-0",children:(0,s.jsx)("code",{className:"text-[#f0f0f0]",children:"string"==typeof n?n.trimEnd().split("\n").map((e,t)=>e.includes("Traceback")?(0,s.jsx)("div",{className:"text-yellow-400",children:e},t):e.includes("NameError")?(0,s.jsx)("div",{className:"text-red-500 font-semibold",children:e},t):(0,s.jsx)("div",{children:e},t)):n})})]})}}},e=>{var t=t=>e(e.s=t);e.O(0,[809,636,593,792],()=>t(468)),_N_E=e.O()}]);